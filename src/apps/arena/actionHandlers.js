import { Animated } from 'react-native'
import Share from 'react-native-share'

import _isEmpty from '@lodash/isEmpty'
import _findIndex from '@lodash/findIndex'
import _isInteger from '@lodash/isInteger'
import _noop from '@lodash/noop'

import { SOMETHING_WENT_WRONG } from '@resources/stringLiterals'
import {
    GAME_STATE,
    DEEPLINK_HOST_NAME,
} from '@resources/constants'

import { emit } from '../../utils/GlobalEventBus'

import { consoleLog } from '../../utils/util'

import { EVENTS } from '../../constants/events'
import { BoardIterators } from '@domain/board/utils/boardIterators'
import { handleMenuItemPress as handleMenuItemPressUseCase } from '@application/usecases/newGameMenu'

import { MainNumbersRecord } from '@domain/board/records/mainNumbersRecord'
import { handleInitSharedPuzzle } from '@application/usecases/startSharedPuzzle'
import { pauseGame } from '@application/usecases/pauseGame'
import { resumeGame } from '@application/usecases/resumeGame'
import { GameState } from '@application/utils/gameState'
import { isAutoGeneratedPuzzleType } from './utils/util'
import { saveCompletedGame } from '@application/usecases/gameLevels/gameLevels'
import { startGameUseCase } from '@application/usecases/startGameUseCase'
import { Board } from '@domain/board/board'
import { HINTS_IDS } from './utils/smartHints/constants'
import { BOARD_MOVES_TYPES, GAME_LEVEL_VS_CLUES } from '@application/constants'
import { generateAndStartNewGameUseCase } from '@application/usecases/generateAndStartNewGame'
import { AUTO_GENERATED_NEW_GAME_IDS } from '@application/usecases/newGameMenu/constants'
import { getNotesInfo } from './store/selectors/board.selectors'
import { NotesRecord } from '@domain/board/records/notesRecord'
import { HINT_ID_VS_RAW_HINT_TRANSFORMERS, getTransformedRawHints } from './utils/smartHints'
import _forEach from '@lodash/forEach'
import _cloneDeep from '@lodash/cloneDeep'
import _get from '@lodash/get'

var RNFS = require('react-native-fs');

const _handleInitSharedPuzzle = async ({ params: { puzzleUrl, dependencies } }) => {
    handleInitSharedPuzzle(puzzleUrl, dependencies)
}

const handleMenuItemPress = ({ setState, params: { selectedGameMenuItem, levelNum, dependencies } }) => {
    const customPuzzleInputToggler = {
        open: () => setState({ showCustomPuzzleHC: true }),
        close: () => setState({ showCustomPuzzleHC: false })
    }
    handleMenuItemPressUseCase(
        { itemId: selectedGameMenuItem, levelNum },
        { ...dependencies, customPuzzleInputToggler }
    )
}

const handleCustomPuzzleHCClose = ({ setState }) => {
    setState({ showCustomPuzzleHC: false })
}

// TODO: take it out
const handleSharePuzzle = ({ params: { dependencies } }) => {
    const { boardRepository } = dependencies
    const mainNumbers = boardRepository.getMainNumbers()

    let puzzleString = ''
    BoardIterators.forBoardEachCell(({ row, col }) => {
        const num = MainNumbersRecord.isClueCell(mainNumbers, { row, col })
            ? MainNumbersRecord.getCellMainValue(mainNumbers, { row, col }) : 0
        puzzleString = `${puzzleString}${num}`
    })

    const options = {
        message: 'Solve This Sudoku Challenge',
        url: `${DEEPLINK_HOST_NAME}${puzzleString}`,
    }
    Share.open(options)
        .then(_noop, _noop)
        .catch(error => {
            consoleLog(error)
            emit(EVENTS.LOCAL.SHOW_SNACK_BAR, { msg: SOMETHING_WENT_WRONG })
        })
}

const handleScreenOutOfFocus = ({ params: { gameState, dependencies } }) => {
    pauseGame(gameState, dependencies)
}

const handleScreenInFocus = ({ params: { dependencies } }) => {
    resumeGame(dependencies)
}

const handleHideGameOverCard = ({ setState, params: { fadeAnim, dependencies } }) => {
    Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
    }).start(() => {
        setState({ showGameSolvedCard: false })
        setTimeout(() => {
            setState({ showNextGameMenu: true })

            const { gameStateRepository } = dependencies
            gameStateRepository.setGameState(GAME_STATE.GAME_SELECT)
        }, 100)
    })
}

const handleNewGameMenuClose = ({ setState }) => {
    setState({ showNextGameMenu: false })
}

const handleGameOver = ({ setState, params: { hcAnimatedValue: fadeAnim, gameStats, gameState, dependencies } }) => {
    setState({ showGameSolvedCard: true }, () => {
        Animated.timing(fadeAnim, {
            toValue: 1,
            duration: 300,
            useNativeDriver: true,
        }).start()
    })

    if (new GameState(gameState).isGameSolved()) {
        const { level } = gameStats
        if (isAutoGeneratedPuzzleType(level)) saveCompletedGame(gameStats, dependencies)
    }
}

const huntPuzzles = async ({
    params: { dependencies }
}) => {
    const { puzzle } = dependencies

    const HINTS_VS_TOUGHNESS = {
        [HINTS_IDS.NAKED_SINGLE]: 1,
        [HINTS_IDS.HIDDEN_SINGLE]: 2,
        [HINTS_IDS.OMISSION]: 3,
        [HINTS_IDS.NAKED_DOUBLE]: 4,
        [HINTS_IDS.HIDDEN_DOUBLE]: 5,
        [HINTS_IDS.NAKED_TRIPPLE]: 6,
        [HINTS_IDS.HIDDEN_TRIPPLE]: 7,
        [HINTS_IDS.X_WING]: 8,
        [HINTS_IDS.Y_WING]: 9,
        [HINTS_IDS.XYZ_WING]: 10,
        [HINTS_IDS.EMPTY_RECTANGLE]: 11,
        [HINTS_IDS.W_WING]: 12,
        [HINTS_IDS.REMOTE_PAIRS]: 13,
        [HINTS_IDS.X_CHAIN]: 14,
        [HINTS_IDS.XY_CHAIN]: 15,
        [HINTS_IDS.UNIQUE_RECTANGLE]: 16,
    }

    const getPuzzleString = (mainNumbers) => {
        const puzzleMainNumbers = []
        BoardIterators.forBoardEachCell(cell => {
            puzzleMainNumbers.push(MainNumbersRecord.getCellMainValue(mainNumbers, cell))
        })
        return puzzleMainNumbers.join('')
    }

    const orderHints = (usedHints) => {
        const hints = Object.keys(usedHints)
        return hints.sort((hintA, hintB) => {
            return HINTS_VS_TOUGHNESS[hintA] - HINTS_VS_TOUGHNESS[hintB]
        })
    }

    const getFreshNotes = (mainNumbers) => {
        const notes = NotesRecord.initNotes()
        const newNotesBunchToAdd = Board.getNewNotesToSpawn(mainNumbers, notes)
        newNotesBunchToAdd.forEach(({ cell, note }) => {
            notes[cell.row][cell.col][note - 1].show = 1
        })
        return notes
    }

    const applyTheHint = (mainNumbers, notes, applyHint) => {
        _forEach(applyHint, ({ cell, action }) => {
            if (action.type === BOARD_MOVES_TYPES.ADD) {
                const notesBunch = Board.getNotesToRemoveAfterMainNumberInput(action.mainNumber, cell, notes)
                _forEach(notesBunch, ({ cell, note }) => {
                    notes[cell.row][cell.col][note - 1].show = 0
                })
                mainNumbers[cell.row][cell.col].value = action.mainNumber
            } else {
                _forEach(_get(action, 'notes'), note => {
                    notes[cell.row][cell.col][note - 1].show = 0
                })
            }
        })
    }

    const puzzles = []
    let puzzlesTried = 0
    while (puzzles.length !== 200) {
        const mainNumbers = await puzzle.getSudokuPuzzle(24)
        const notes = getFreshNotes(mainNumbers)
        const originalPuzzleStr = getPuzzleString(mainNumbers)

        const hintsUsed = {}

        let skipPuzzle = false

        while (!Board.isPuzzleSolved(mainNumbers)) {
            const rawHints = await puzzle.getRawHints(getPuzzleString(mainNumbers), _cloneDeep(notes), [])
            const orderedHints = orderHints(rawHints)
            if (!orderedHints.length) {
                skipPuzzle = true
                break
            }
            hintsUsed[orderedHints[0]] = true

            const { applyHint } = HINT_ID_VS_RAW_HINT_TRANSFORMERS[orderedHints[0]]({
                rawHint: rawHints[orderedHints[0]],
                mainNumbers,
                notesData: notes,
                smartHintsColorSystem: {},
            })
            applyTheHint(mainNumbers, notes, applyHint)
        }

        if (skipPuzzle) continue

        const orderedHints = orderHints(hintsUsed)
        const hardestPuzzleRank = orderedHints[orderedHints.length - 1]

        if (hardestPuzzleRank >= 4 && hardestPuzzleRank <= 10) {
            puzzles.push({
                puzzle: originalPuzzleStr,
                hintsUsed: orderHints(hintsUsed),
            })
        }

        console.log('@@@@@ puzzles tried', ++puzzlesTried)
    }

    try {
        var path = RNFS.DocumentDirectoryPath + '/puzzles.txt';
        RNFS.writeFile(path, JSON.stringify(puzzles))
            .then((success) => {
                console.log('FILE WRITTEN!');
            })
            .catch((err) => {
                console.log(err.message);
            });
    } catch (err) {
        console.log('@@@@@ err', err)
    }

}

const ACTION_TYPES = {
    ON_SHARE_CLICK: 'ON_SHARE_CLICK',
    ON_INIT_SHARED_PUZZLE: 'ON_INIT_SHARED_PUZZLE',
    ON_NEW_GAME_MENU_ITEM_PRESS: 'ON_NEW_GAME_MENU_ITEM_PRESS',
    ON_START_CUSTOM_PUZZLE: 'ON_START_CUSTOM_PUZZLE',
    ON_CUSTOM_PUZZLE_HC_CLOSE: 'ON_CUSTOM_PUZZLE_HC_CLOSE',
    ON_OUT_OF_FOCUS: 'ON_OUT_OF_FOCUS',
    ON_IN_FOCUS: 'ON_IN_FOCUS',
    ON_HIDE_GAME_OVER_CARD: 'ON_HIDE_GAME_OVER_CARD',
    ON_NEW_GAME_MENU_CLOSE: 'ON_NEW_GAME_MENU_CLOSE',
    ON_GAME_OVER: 'ON_GAME_OVER',
    HUNT_PUZZLES: 'HUNT_PUZZLES'
}

const ACTION_HANDLERS = {
    [ACTION_TYPES.ON_SHARE_CLICK]: handleSharePuzzle,
    [ACTION_TYPES.ON_INIT_SHARED_PUZZLE]: _handleInitSharedPuzzle,
    [ACTION_TYPES.ON_NEW_GAME_MENU_ITEM_PRESS]: handleMenuItemPress,
    [ACTION_TYPES.ON_CUSTOM_PUZZLE_HC_CLOSE]: handleCustomPuzzleHCClose,
    [ACTION_TYPES.ON_OUT_OF_FOCUS]: handleScreenOutOfFocus,
    [ACTION_TYPES.ON_IN_FOCUS]: handleScreenInFocus,
    [ACTION_TYPES.ON_HIDE_GAME_OVER_CARD]: handleHideGameOverCard,
    [ACTION_TYPES.ON_NEW_GAME_MENU_CLOSE]: handleNewGameMenuClose,
    [ACTION_TYPES.ON_GAME_OVER]: handleGameOver,
    [ACTION_TYPES.HUNT_PUZZLES]: huntPuzzles,
}

export { ACTION_TYPES, ACTION_HANDLERS }
